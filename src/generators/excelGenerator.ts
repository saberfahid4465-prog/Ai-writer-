/**
 * AI Writer — Excel (.xlsx) Generator
 *
 * Generates a professional Excel spreadsheet from the
 * AI-structured excel data using ExcelJS.
 *
 * Features:
 * - Styled header row (bold, colored background)
 * - Auto-fit column widths
 * - Borders and cell alignment
 * - UTF-8 support
 * - Compatible with Office 2007+, WPS, Google Sheets, LibreOffice
 */

import ExcelJS from 'exceljs';
import { ExcelData, PdfWordData } from '../ai/responseParser';
import { DocumentImage } from '../services/pexelsService';
import { uint8ArrayToBase64 } from '../utils/base64Polyfill';

// ─── Theme Constants ────────────────────────────────────────────

const HEADER_BG_COLOR = '2C2E33'; // Dark charcoal
const HEADER_FONT_COLOR = 'FFFFFF'; // White
const BODY_FONT_COLOR = '1E1F23'; // Near-black
const BORDER_COLOR = 'D5D5DA'; // Light gray
const ALT_ROW_COLOR = 'F0F0F2'; // Alternating row highlight
const FONT_NAME = 'Calibri';

// ─── Generator ──────────────────────────────────────────────────

/**
 * Generate an Excel (.xlsx) file from structured AI data.
 *
 * @param excelData - The excel section of the AI response.
 * @param metaData - The pdf_word section (for title/author metadata).
 * @returns Base64 string of the .xlsx file.
 */
export async function generateExcel(
  excelData: ExcelData,
  metaData: PdfWordData,
  images?: Map<string, DocumentImage>
): Promise<string> {
  const workbook = new ExcelJS.Workbook();

  // Set workbook metadata
  workbook.creator = metaData.author || 'AI Writer';
  workbook.created = new Date();
  workbook.modified = new Date();
  workbook.lastModifiedBy = 'AI Writer';

  // ─── Main Data Sheet ─────────────────────────────────────
  const sheet = workbook.addWorksheet(metaData.title || 'AI Writer Output', {
    properties: {
      defaultColWidth: 25,
    },
  });

  // Title row (merged across all columns)
  const titleRow = sheet.addRow([metaData.title]);
  sheet.mergeCells(1, 1, 1, excelData.headers.length);
  titleRow.font = {
    name: FONT_NAME,
    size: 16,
    bold: true,
    color: { argb: `FF${HEADER_BG_COLOR}` },
  };
  titleRow.alignment = { horizontal: 'center', vertical: 'middle' };
  titleRow.height = 35;

  // Subtitle row
  const subtitleRow = sheet.addRow([
    `Generated by ${metaData.author || 'AI Writer'} | Language: ${metaData.language}`,
  ]);
  sheet.mergeCells(2, 1, 2, excelData.headers.length);
  subtitleRow.font = {
    name: FONT_NAME,
    size: 10,
    italic: true,
    color: { argb: 'FF999999' },
  };
  subtitleRow.alignment = { horizontal: 'center', vertical: 'middle' };
  subtitleRow.height = 22;

  // Empty spacer row
  sheet.addRow([]);

  // ─── Header Row ──────────────────────────────────────────
  const headerRow = sheet.addRow(excelData.headers);
  headerRow.height = 28;

  headerRow.eachCell((cell, colNumber) => {
    cell.font = {
      name: FONT_NAME,
      size: 12,
      bold: true,
      color: { argb: `FF${HEADER_FONT_COLOR}` },
    };
    cell.fill = {
      type: 'pattern',
      pattern: 'solid',
      fgColor: { argb: `FF${HEADER_BG_COLOR}` },
    };
    cell.alignment = {
      horizontal: 'center',
      vertical: 'middle',
      wrapText: true,
    };
    cell.border = {
      top: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
      bottom: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
      left: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
      right: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
    };
  });

  // ─── Data Rows ───────────────────────────────────────────
  excelData.rows.forEach((rowData, index) => {
    const dataRow = sheet.addRow(rowData);
    dataRow.height = 24;

    dataRow.eachCell((cell) => {
      cell.font = {
        name: FONT_NAME,
        size: 11,
        color: { argb: `FF${BODY_FONT_COLOR}` },
      };
      cell.alignment = {
        horizontal: 'left',
        vertical: 'middle',
        wrapText: true,
      };
      cell.border = {
        top: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
        bottom: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
        left: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
        right: { style: 'thin', color: { argb: `FF${BORDER_COLOR}` } },
      };

      // Alternating row colors
      if (index % 2 === 1) {
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: `FF${ALT_ROW_COLOR}` },
        };
      }
    });
  });

  // ─── Auto-fit Column Widths ──────────────────────────────
  sheet.columns.forEach((column, i) => {
    let maxLength = excelData.headers[i]?.length || 10;
    excelData.rows.forEach((row) => {
      const cellLength = row[i]?.toString().length || 0;
      if (cellLength > maxLength) {
        maxLength = cellLength;
      }
    });
    column.width = Math.min(Math.max(maxLength + 4, 15), 60);
  });

  // ─── Images Sheet ──────────────────────────────────
  if (images && images.size > 0) {
    try {
      const imgSheet = workbook.addWorksheet('Images', {
        properties: { defaultColWidth: 30 },
      });

      const imgTitleRow = imgSheet.addRow(['Visual References']);
      imgSheet.mergeCells(1, 1, 1, 3);
      imgTitleRow.font = {
        name: FONT_NAME,
        size: 16,
        bold: true,
        color: { argb: `FF${HEADER_BG_COLOR}` },
      };
      imgTitleRow.alignment = { horizontal: 'center' };
      imgTitleRow.height = 35;

      imgSheet.addRow([]);

      const imgHeaderRow = imgSheet.addRow(['Section Keyword', 'Photographer', 'Image']);
      imgHeaderRow.height = 28;
      imgHeaderRow.eachCell((cell) => {
        cell.font = {
          name: FONT_NAME,
          size: 12,
          bold: true,
          color: { argb: `FF${HEADER_FONT_COLOR}` },
        };
        cell.fill = {
          type: 'pattern',
          pattern: 'solid',
          fgColor: { argb: `FF${HEADER_BG_COLOR}` },
        };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
      });

      let imgRowNum = 4;
      for (const [keyword, img] of images) {
        const row = imgSheet.addRow([keyword, `${img.photographer} / Pexels`, '']);
        row.height = 120;
        row.eachCell((cell) => {
          cell.font = { name: FONT_NAME, size: 11 };
          cell.alignment = { horizontal: 'left', vertical: 'middle' };
        });

        try {
          // Convert Uint8Array to base64 for ExcelJS (Buffer not available in Hermes)
          const imgBase64 = uint8ArrayToBase64(img.imageBytes);
          const imageId = workbook.addImage({
            base64: imgBase64,
            extension: 'jpeg',
          });
          imgSheet.addImage(imageId, {
            tl: { col: 2, row: imgRowNum - 1 },
            ext: { width: 250, height: 150 },
          });
        } catch (e) {
          console.warn('Failed to embed image in Excel:', e);
        }
        imgRowNum++;
      }

      imgSheet.getColumn(1).width = 25;
      imgSheet.getColumn(2).width = 25;
      imgSheet.getColumn(3).width = 40;
    } catch (e) {
      console.warn('Failed to create images sheet in Excel:', e);
    }
  }

  // ─── Export as base64 (safe for React Native) ─────────
  const arrayBuffer = await workbook.xlsx.writeBuffer();
  const bytes = new Uint8Array(arrayBuffer as ArrayBuffer);
  return uint8ArrayToBase64(bytes);
}
